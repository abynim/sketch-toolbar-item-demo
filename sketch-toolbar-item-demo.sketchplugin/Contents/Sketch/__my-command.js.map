{"version":3,"sources":["webpack://exports/webpack/bootstrap","webpack://exports/./node_modules/@skpm/nib-loader/lib/nib-class.js","webpack://exports/./node_modules/sketch-toolbar-item/SketchToolbarIcon.framework/SketchToolbarIcon","webpack://exports/./node_modules/@skpm/xcodeproj-loader/lib/xcodeproj-class.js","webpack://exports/./node_modules/cocoascript-class/lib/index.js","webpack://exports/./node_modules/cocoascript-class/lib/runtime.js","webpack://exports/./node_modules/sketch-toolbar-item/sketch-toolbar-icon.js","webpack://exports/./src/my-command.js","webpack://exports/external \"sketch\""],"names":["sayHello","UI","alert","sayNamaste","sayGoodbye","validateToolbarItem","context","toolbarItem","doc","sketch","getSelectedDocument","selectedLayers","enabled","isEmpty","registerToolbarActions","SketchToolbar","registerToolbarAction","item1","specifierForToolbarAction","item2","registerToolbarGroup","menuItem1","menuItemForToolbarAction","menuItem2","menuItem3","separatorMenuItem","menuItem4","registerToolbarMenu"],"mappings":";;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA,eAAe,mBAAO,CAAC,wEAAmB;;AAE1C;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;;;;;;ACtEA,iBAAiB,mBAAO,CAAC,kIAAuG,oD;;;;;;;;;;;ACAhI;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,wFAAgC;AACvD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,mBAAO,CAAC,wFAAgC;AACvD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;;ACnFa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,eAAe,mBAAO,CAAC,qEAAc;;AAErC;;AAEA;AACA;;AAEA,6EAA6E,YAAY;;AAEzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7Da;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA,kCAAkC,qCAAqC;;AAEvE;AACA;AACA,4CAA4C,sCAAsC,GAAG,YAAY;AACjG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ,YAAY,WAAW;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,8GAA8G,YAAY,GAAG,YAAY,GAAG,aAAa,IAAI,UAAU,WAAW,GAAG;AACrL;AACA,8GAA8G,YAAY,GAAG,YAAY,GAAG,YAAY,IAAI,UAAU,WA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","file":"__my-command.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/my-command.js\");\n","/* eslint-disable no-var, prefer-template, vars-on-top, no-underscore-dangle, prefer-arrow-callback, no-param-reassign */\n/* globals NSUUID, MOClassDescription, NSBundle, NSObject, __command, MOPointer */\nvar ObjClass = require('cocoascript-class').default;\n\nfunction walkViewTree(rootView, fn) {\n  function _visit(view) {\n    fn(view);\n\n    var subviews = view.subviews();\n    for (var i = 0; i < subviews.count(); i++) {\n      _visit(subviews.objectAtIndex(i));\n    }\n  }\n\n  _visit(rootView);\n}\n\nvar CONTAINS_EXT = /\\.nib$/;\n\nfunction NibClass(nibName, delegate, bundleURL) {\n  if (CONTAINS_EXT.test(nibName)) {\n    nibName = nibName.replace(CONTAINS_EXT, '');\n  }\n  var bundle = NSBundle.bundleWithURL(bundleURL || __command.pluginBundle().url());\n\n  var nibOwner = (new ObjClass(delegate || {})).new();\n  var root;\n\n  var result = {\n    getOwner() {\n      return nibOwner;\n    },\n    getRoot() {\n      return root;\n    },\n  };\n\n  var topLevelObjectsPointer = MOPointer.alloc().initWithValue(null);\n\n  var didManagedToLoad = bundle.loadNibNamed_owner_topLevelObjects(\n    nibName,\n    nibOwner,\n    topLevelObjectsPointer,\n  );\n\n  if (!didManagedToLoad) {\n    throw new Error('Error loading nib file ' + nibName + '.nib');\n  }\n\n  var topLevelObjects = topLevelObjectsPointer.value();\n  for (var i = 0; i < topLevelObjects.count(); i++) {\n    var obj = topLevelObjects.objectAtIndex(i);\n    if (/View$/.test(String(obj.className()))) {\n      root = obj;\n      break;\n    }\n  }\n\n  // find the views that have an identifier for easy access\n  // we don't take the ones starting with _ since it's probably internal identifiers (used by cocoa)\n  walkViewTree(root, function visit(view) {\n    var id = String(view.identifier());\n    if (id && id.indexOf('_') !== 0) {\n      result[id] = view;\n    }\n  });\n\n  return result;\n}\n\nmodule.exports = NibClass;\n","module.exports = require('/Users/aby/Github/sketch-toolbar-item-demo/node_modules/@skpm/xcodeproj-loader/lib/xcodeproj-class.js')('_webpack_resources/SketchToolbarIcon.framework');","/* eslint-disable no-var, prefer-template, prefer-arrow-callback, global-require, no-param-reassign, vars-on-top */\n/* globals NSClassFromString, __command, __mocha__, NSURL */\n\nvar CONTAINS_EXT = /\\.framework$/;\n\nfunction xcodeprojClass(frameworkName) {\n  if (typeof __command === 'undefined' || !__command.pluginBundle()) {\n    throw new Error('missing plugin bundle :thinking_face:');\n  }\n\n  if (CONTAINS_EXT.test(frameworkName)) {\n    frameworkName = frameworkName.replace(CONTAINS_EXT, '');\n  }\n\n  var frameworkPath = __command\n    .pluginBundle()\n    .url()\n    .path()\n    .stringByAppendingPathComponent('Contents')\n    .stringByAppendingPathComponent('Resources');\n\n  var parts = frameworkName.split('/');\n  parts.forEach(function fixPath(part, i) {\n    if (i !== parts.length - 1) {\n      frameworkPath = frameworkPath.stringByAppendingPathComponent(part);\n    } else {\n      frameworkName = part;\n    }\n  });\n\n  return {\n    getClass(className) {\n      var existingClass = NSClassFromString(className);\n      if (!existingClass) {\n        if (\n          !__mocha__.loadFrameworkWithName_inDirectory(\n            frameworkName,\n            frameworkPath,\n          )\n        ) {\n          throw new Error(\"Couldn't load framework \" + frameworkName);\n        }\n        existingClass = NSClassFromString(className);\n      }\n\n      if (!existingClass) {\n        throw new Error(\"Couldn't find class \" + className);\n      }\n\n      return existingClass;\n    },\n    getNib(nibName, delegate) {\n      var bundleURL = NSURL.fileURLWithPath(\n        frameworkPath.stringByAppendingPathComponent(frameworkName) +\n          '.framework',\n      );\n\n      try {\n        return require('@skpm/nib-loader/lib/nib-class')(\n          nibName,\n          delegate,\n          bundleURL,\n        );\n      } catch (err) {\n        if (\n          !__mocha__.loadFrameworkWithName_inDirectory(\n            frameworkName,\n            frameworkPath,\n          )\n        ) {\n          throw new Error(\"Couldn't load framework \" + frameworkName);\n        }\n\n        return require('@skpm/nib-loader/lib/nib-class')(\n          nibName,\n          delegate,\n          bundleURL,\n        );\n      }\n    },\n  };\n}\n\nmodule.exports = xcodeprojClass;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SuperCall = undefined;\nexports.default = ObjCClass;\n\nvar _runtime = require(\"./runtime.js\");\n\nexports.SuperCall = _runtime.SuperCall;\n\n// super when returnType is id and args are void\n// id objc_msgSendSuper(struct objc_super *super, SEL op, void)\n\nconst SuperInit = (0, _runtime.SuperCall)(NSStringFromSelector(\"init\"), [], { type: \"@\" });\n\n// Returns a real ObjC class. No need to use new.\nfunction ObjCClass(defn) {\n  const superclass = defn.superclass || NSObject;\n  const className = (defn.className || defn.classname || \"ObjCClass\") + NSUUID.UUID().UUIDString();\n  const reserved = new Set(['className', 'classname', 'superclass']);\n  var cls = MOClassDescription.allocateDescriptionForClassWithName_superclass_(className, superclass);\n  // Add each handler to the class description\n  const ivars = [];\n  for (var key in defn) {\n    const v = defn[key];\n    if (typeof v == 'function' && key !== 'init') {\n      var selector = NSSelectorFromString(key);\n      cls.addInstanceMethodWithSelector_function_(selector, v);\n    } else if (!reserved.has(key)) {\n      ivars.push(key);\n      cls.addInstanceVariableWithName_typeEncoding(key, \"@\");\n    }\n  }\n\n  cls.addInstanceMethodWithSelector_function_(NSSelectorFromString('init'), function () {\n    const self = SuperInit.call(this);\n    ivars.map(name => {\n      Object.defineProperty(self, name, {\n        get() {\n          return getIvar(self, name);\n        },\n        set(v) {\n          (0, _runtime.object_setInstanceVariable)(self, name, v);\n        }\n      });\n      self[name] = defn[name];\n    });\n    // If there is a passsed-in init funciton, call it now.\n    if (typeof defn.init == 'function') defn.init.call(this);\n    return self;\n  });\n\n  return cls.registerClass();\n};\n\nfunction getIvar(obj, name) {\n  const retPtr = MOPointer.new();\n  (0, _runtime.object_getInstanceVariable)(obj, name, retPtr);\n  return retPtr.value().retain().autorelease();\n}","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SuperCall = SuperCall;\nexports.CFunc = CFunc;\nconst objc_super_typeEncoding = '{objc_super=\"receiver\"@\"super_class\"#}';\n\n// You can store this to call your function. this must be bound to the current instance.\nfunction SuperCall(selector, argTypes, returnType) {\n  const func = CFunc(\"objc_msgSendSuper\", [{ type: '^' + objc_super_typeEncoding }, { type: \":\" }, ...argTypes], returnType);\n  return function (...args) {\n    const struct = make_objc_super(this, this.superclass());\n    const structPtr = MOPointer.alloc().initWithValue_(struct);\n    return func(structPtr, selector, ...args);\n  };\n}\n\n// Recursively create a MOStruct\nfunction makeStruct(def) {\n  if (typeof def !== 'object' || Object.keys(def).length == 0) {\n    return def;\n  }\n  const name = Object.keys(def)[0];\n  const values = def[name];\n\n  const structure = MOStruct.structureWithName_memberNames_runtime(name, Object.keys(values), Mocha.sharedRuntime());\n\n  Object.keys(values).map(member => {\n    structure[member] = makeStruct(values[member]);\n  });\n\n  return structure;\n}\n\nfunction make_objc_super(self, cls) {\n  return makeStruct({\n    objc_super: {\n      receiver: self,\n      super_class: cls\n    }\n  });\n}\n\n// Due to particularities of the JS bridge, we can't call into MOBridgeSupport objects directly\n// But, we can ask key value coding to do the dirty work for us ;)\nfunction setKeys(o, d) {\n  const funcDict = NSMutableDictionary.dictionary();\n  funcDict.o = o;\n  Object.keys(d).map(k => funcDict.setValue_forKeyPath(d[k], \"o.\" + k));\n}\n\n// Use any C function, not just ones with BridgeSupport\nfunction CFunc(name, args, retVal) {\n  function makeArgument(a) {\n    if (!a) return null;\n    const arg = MOBridgeSupportArgument.alloc().init();\n    setKeys(arg, {\n      type64: a.type\n    });\n    return arg;\n  }\n  const func = MOBridgeSupportFunction.alloc().init();\n  setKeys(func, {\n    name: name,\n    arguments: args.map(makeArgument),\n    returnValue: makeArgument(retVal)\n  });\n  return func;\n}\n\n/*\n@encode(char*) = \"*\"\n@encode(id) = \"@\"\n@encode(Class) = \"#\"\n@encode(void*) = \"^v\"\n@encode(CGRect) = \"{CGRect={CGPoint=dd}{CGSize=dd}}\"\n@encode(SEL) = \":\"\n*/\n\nfunction addStructToBridgeSupport(key, structDef) {\n  // OK, so this is probably the nastiest hack in this file.\n  // We go modify MOBridgeSupportController behind its back and use kvc to add our own definition\n  // There isn't another API for this though. So the only other way would be to make a real bridgesupport file.\n  const symbols = MOBridgeSupportController.sharedController().valueForKey('symbols');\n  if (!symbols) throw Error(\"Something has changed within bridge support so we can't add our definitions\");\n  // If someone already added this definition, don't re-register it.\n  if (symbols[key] !== null) return;\n  const def = MOBridgeSupportStruct.alloc().init();\n  setKeys(def, {\n    name: key,\n    type: structDef.type\n  });\n  symbols[key] = def;\n};\n\n// This assumes the ivar is an object type. Return value is pretty useless.\nconst object_getInstanceVariable = exports.object_getInstanceVariable = CFunc(\"object_getInstanceVariable\", [{ type: \"@\" }, { type: '*' }, { type: \"^@\" }], { type: \"^{objc_ivar=}\" });\n// Again, ivar is of object type\nconst object_setInstanceVariable = exports.object_setInstanceVariable = CFunc(\"object_setInstanceVariable\", [{ type: \"@\" }, { type: '*' }, { type: \"@\" }], { type: \"^{objc_ivar=}\" });\n\n// We need Mocha to understand what an objc_super is so we can use it as a function argument\naddStructToBridgeSupport('objc_super', { type: objc_super_typeEncoding });","const SketchToolbarIconClass = require('@skpm/xcodeproj-loader?raw=true&publicPath=_webpack_resources&outputPath=../Resources/_webpack_resources!./SketchToolbarIcon.framework/SketchToolbarIcon').getClass('SketchToolbarIcon');\n\nmodule.exports = function() {\n\n  let o = {};\n\n  /**\n  * @param {any} context - The current context\n  * @param {string} commandID - The identifier of the command this item will trigger\n  * @param {string} iconImagePath - A relative path to a 32x32px png image. To include a separate image path for dark mode use | to separate their path names\n  */\n  o.registerToolbarAction = function(context, commandID, iconImagePath) {\n    SketchToolbarIconClass.registerToolbarAction_commandID_iconImagePath(context, commandID, iconImagePath);\n  }\n\n  /**\n  * @param {any} context - The current context\n  * @param {string} commandID - The identifier of the command this item will trigger\n  * @param {string} iconImagePath - A relative path to a 32x32px png image. To include a separate image path for dark mode use | to separate their path names\n  *  @returns {any} A toolbar item specifier which can be used to register a toolbar item group\n  */\n  o.specifierForToolbarAction = function(context, commandID, iconImagePath) {\n    return SketchToolbarIconClass.specifierForToolbarAction_commandID_iconImagePath(context, commandID, iconImagePath);\n  }\n\n  /**\n  * @param {any} context - The current context\n  * @param {string} identifier - A unique identifier for the group item\n  * @param {Array} specifiers - An array of specifiers created using `specifierForToolbarAction`\n  */\n  o.registerToolbarGroup = function (context, identifier, specifiers) {\n    SketchToolbarIconClass.registerToolbarGroup_identifier_specifiers(context, identifier, specifiers);\n  }\n\n  /**\n  * @param {any} context - The current context\n  * @param {string} commandID - A unique identifier for the group item\n  * @param {string} iconImagePath - A relative path to a 32x32px png image. To include a separate image path for dark mode use | to separate their path names\n  * @returns {any} A menu item specifier to be used when registering a toolbar item with a dropdown menu\n  */\n  o.menuItemForToolbarAction = function(context, commandID, iconImagePath) {\n    return SketchToolbarIconClass.menuItemForToolbarAction_commandID_iconImagePath(context, commandID, iconImagePath);\n  }\n\n  /**\n  *  @returns {any} A separator menu item specifier to be used when registering a toolbar item with a dropdown menu\n  */\n  o.separatorMenuItem = function () {\n    return SketchToolbarIconClass.separatorMenuItem();\n  }\n\n  /**\n  * @param {any} context - The current context\n  * @param {string} identifier - A unique identifier for the toolbar item\n  * @param {string} title - The text to be displayed below in the toolbar item\n  * @param {string} iconImagePath - A relative path to a 32x32px png image. To include a separate image path for dark mode use | to separate their path names\n  * @param {Array} menuItems - An array of menu item specifiers created using `menuItemForToolbarAction` or `separatorMenuItem`\n  */\n  o.registerToolbarMenu = function (context, identifier, title, iconImagePath, menuItems) {\n    SketchToolbarIconClass.registerToolbarMenu_identifier_title_iconImagePath_menuItems(context, identifier, title, iconImagePath, menuItems);\n  }\n\n  return o;\n\n}();","import sketch, { UI } from 'sketch'\nimport SketchToolbar from 'sketch-toolbar-item'\n\n// Handlers for the toolbar item's run action\nexport function sayHello() {\n  UI.alert('Hello from the toolbar!', 'Have a great day 👋')\n}\n\nexport function sayNamaste() {\n  UI.alert('Namaste from the toolbar!', 'Be cool 🙏')\n}\n\nexport function sayGoodbye() {\n  UI.alert('Goodbye from the toolbar!', 'See ya later, maybe ✌️')\n}\n\n// The handler for the toolbar item's validate action\n// If this method is not implemented, your toolbar item is always enabled\n// NOTE: Keep this method light. Doing too much here will slow down Sketch\nexport function validateToolbarItem(context) {\n\n  // Get a reference to your toolbar item via context\n  let toolbarItem = context.toolbarItem\n\n  let doc = sketch.getSelectedDocument()\n  let selectedLayers = doc.selectedLayers\n\n  // As an example: enable the toolbar item if selection is not empty\n  toolbarItem.enabled = !selectedLayers.isEmpty\n\n  // To change the item's icon during validation,\n  // pass a relative path to another 32x32px image in your plugin's Resources folder:\n  // This is entirely optional!\n\n  // toolbarItem.iconImagePath = selectedLayers.isEmpty ? \"hello-toolbar-icon-flipped.png\" : \"hello-toolbar-icon.png\";\n}\n\nexport function registerToolbarActions(context) {\n\n  // register a single toolbar item by passing:\n  // 1. the current context\n  // 2. the command identifier of the action this item will trigger\n  // 3. the relative path to a 32x32px icon image in your plugin's Resources folder\n\n  // To add a different image for dark mode, separate the image paths with a |\n  SketchToolbar.registerToolbarAction(context, 'goodbye', 'goodbye-toolbar-icon.png|goodbye-toolbar-icon-dark.png')\n\n  // ------------------------\n\n  // to register a group of items, create specifiers for each item then register them as a group\n  let item1 = SketchToolbar.specifierForToolbarAction(context, 'namaste', 'namaste-toolbar-icon.png|namaste-toolbar-icon-dark.png')\n  let item2 = SketchToolbar.specifierForToolbarAction(context, 'hello', 'hello-toolbar-icon.png|hello-toolbar-icon-dark.png')\n\n  SketchToolbar.registerToolbarGroup(context, 'salutations', [item1, item2])\n\n  // ------------------------\n\n  // to register a toolbar item with a dropdown menu, create a menuItem for each sub-item\n  let menuItem1 = SketchToolbar.menuItemForToolbarAction(context, 'hello', 'hello-toolbar-icon.png|hello-toolbar-icon-dark.png')\n  let menuItem2 = SketchToolbar.menuItemForToolbarAction(context, 'namaste', 'namaste-toolbar-icon.png|namaste-toolbar-icon-dark.png')\n  let menuItem3 = SketchToolbar.separatorMenuItem();\n  let menuItem4 = SketchToolbar.menuItemForToolbarAction(context, 'goodbye', 'goodbye-toolbar-icon.png|goodbye-toolbar-icon-dark.png')\n\n  // Then register them using the `registerToolbarMenu` method\n  SketchToolbar.registerToolbarMenu(context, 'greetings', 'Greetings', 'greetings-toolbar-icon.png|greetings-toolbar-icon-dark.png', [menuItem1, menuItem2, menuItem3, menuItem4])\n\n}","module.exports = require(\"sketch\");"],"sourceRoot":""}